#+TITLE: Array Langs Index
#+AUTHOR: Raimon Grau
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:nil
#+OPTIONS: e:t email:nil f:t inline:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t todo:t |:t
#+EXCLUDE_TAGS: noexport
#+KEYWORDS: bash zsh shell
#+LANGUAGE: en
#+SELECT_TAGS: export

#+OPTIONS: html-style:nil
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+OPTIONS: reveal_center:nil timestamp:nil
#+REVEAL_THEME: black

# toc:nil num:nil
* Generic
- https://gist.github.com/suhr/77f8d0acae5a2399cab950841cc99a05
- https://github.com/k-qy/notation
* APL
Good complete books:
- https://xpqz.github.io/learnapl/intro.html
- https://www.dyalog.com/mastering-dyalog-apl.htm

* J
- https://zserge.com/posts/j/
* K
The main implementation is private, but there are some opensource ones. ngn/k, kona and [[https://github.com/JohnEarnest/ok/][oK]] are the most complete
Very minimalistic. I read somewhere it's like a superpowered calculator.  It has around 20 builtins.
John Earnest taling about k versions: https://www.arraycast.com/episodes/episode41-john-earnest
** Tutotrials
The shape of tutorials of K looks like... Super minimalistic.
- https://kparc.com/
- https://xpqz.github.io/kbook/Introduction.html
- https://github.com/razetime/ngn-k-tutorial/
- https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Manual.md
- https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Programming.md
- http://www.nsl.com/k/k2/k295/kreflite.pdf
- http://www.nsl.com/k/k2/k295/kusrlite.pdf
- http://www.nsl.com/papers/style.pdf
- https://github.com/Dyalog/ride/blob/master/docs/coding-style.txt
- Q for Mortals: https://code.kx.com/q4m3/
- http://www.nsl.com/
- http://archive.vector.org.uk/art10010830
- https://web.archive.org/web/20070519112242/http://www.kuro5hin.org/story/2002/11/14/22741/791
- https://nsl.com/k/training/idioms_K3.pdf
- https://nsl.com/k/training/
- https://web.archive.org/web/20071230205056/http://kx.com/technical/contribs/eugene/kidioms.html
- https://gist.github.com/chrispsn/b1020918a83a28ab8b4442d8aff8d1b4 <- K mezzaine
- https://github.com/kparc/kcc
- https://cs.nyu.edu/~shasha/papers/tutorial
- https://ngn.codeberg.page/txt/tacitjk.pdf
- https://github.com/gitonthescene/ngnk-libs/



** AoC
- https://github.com/qbists/studyq/tree/main/aoc/2022
- https://k.miraheze.org/wiki/Advent_of_Code

** Snippets and wtfs
- day 8 aoc 22
  #+begin_src k
x:0:"i/08"
mv:(-1>':|\)'(+|:)\x
+//|/((!4) (|+:)/'mv)

  #+end_src
- scan or n-dos?
    #+begin_src k
1+:\3 3#!9 \ this is a n-dos
\ Why does the same as
+:\3 3#!9 \ if this is a scan, it should pick rows, not the full table
   #+end_src
- amend fail in ngn/k?
  - https://k.miraheze.org/wiki/Amend
  - https://github.com/kevinlawler/kona/wiki/Amend it works in kona.
  -
    #+begin_src k
  b:2 3#!6
  b+: b  \ Works fine (dyadic),
  .[`b;();+:] \ works fine (monadic)
  b+:  \ That should amend using monadic, but fails in ok and ngn. works in kona
    #+end_src
  - (f;g)@'lst
#+begin_src k
f:1+
g:2+
r:0 1
(x1;x2):r
(f x1; g x2)
(f;g)@r  \ (+1;+2)
(f;g)@'r  \ why?
#+end_src
  -  { \(x;y);x>y}':-5 5 4 8  . \ does print partial results?
#+begin_src k
 { \(x;y);x>y}':-5 5 4 8
-5 0N
5 -5
4 5
8 4
1 1 0 1
#+end_src
  - sort by frequency desc
#+begin_src k
d:(!=s)!(#'.=s)
&(>d)!(d[>d])
/ or
&#'([>#'=s]#=s)
/ or
#:'=s
/
sd:#:'=s
&([>sd]#sd)
/ or
&([>d]#d:#'=s)
#+end_src
or
#+begin_src k
d:#'=s
&(>d)#d
#+end_src

- tacit k hook
  #+begin_src k
    f/1 g\
  #+end_src

- tacit k fork
  #+begin_src k
    g/(f;h)@\:
  #+end_src

- fractals
  https://ngn.codeberg.page/k/#eJyFkd2OmzAQhe95ioloY4Od+AdCkVFWeYK+QBJ1CZAtKmsiIJFTSJ69k1ysqlZVfXE0c/GdOTMuuosZx+XWZVf+MzOZ2t/Elio2CeICX+6X4BZmjs1tw3YERHHuLhXkPdDS9Vl57QNYvMChbRt4z4eudt6ha8zIBTmnhCipY8mYIER+Be0LgyVWse9C6qM/9UNUQhWkmQaVZDFEOktiUDoNbiB+832O6fK6aSrvnJrxtfhEpZOykJU8ym2x54X/oBiVPInZvDCKYQ9axikkq1WU4EI7h6bn4ZhCZYu2rLyjeZUGE29AlHV/avKr5x039/VuN8cU/3uir6vuVNv+Rw2YMbdvGO64CUUoDBHa53e1nsV+9C+8yO3QdlCe+wGxoruAUqPjZCLTQoEK3U3M9N9Y2eVvrYXnVyCXjExTxym/zx7n5JMhgUBU/cmdqty2H9hqPHCivuGwg+GCTsxxmfEcBRPkBs1c8DAR3+vmUHXDB2hHOtHU18EuksFGCxYRIznSt51dz3RoTfQMLbpzU0USCfVifYZHwYsoTekUhQu5XAHKF0ZnNvhsjfaTOGAjXQgXukyHAodvAiFBvOe2rJpD1w7QV4Pn/QKIkrFl
  #+begin_src k
    crv:{{.[x;y,z;:;1]}/[(1+|/'x)#0]. x-:&/'x}@+\' /curve as (dxs;dys) -> bool matrix
brl:{,/'u8''10240++/''0N 2#/:+/'0N 4#x*(#x)#(#*x)#'(1 8;2 16;4 32;64 128)} /bool matrix -> braille
u8:{`c$(0x00c0e0f0[c],c#128)+(0,64+&c:1+128 2048 65536'x)\x} /utf8 encode
f:`0:brl@ /display

f@~=\\&64                                 /sierpinski triangle
f@*/*/:'/2#,~1=!4#3                       /cantor dust
f@crv 11{x,'|'|-1 1*x}/!2                 /dragon curve
f@6{+2(x,(,~!#*x),|:')/x}/1               /peano curve
f@5{b,'1_'|'b:,/(|+x,0;,a,0;x,'a:~!#x)}/1 /hilbert curve
f@n{(|(8#2)\30)@2/+3':0,x,0}\n=!2*n:32    /rule30
f@1>n#+/*/2#,12((|3*-0.5 -0.7+(!n)%n:2#64)+{(-/x*x;2*/x)}@)/0 /mandelbrot set


  #+end_src
-   https://cs.nyu.edu/~shasha/papers/tutorial
  8) There is each left each right (which should be interpreted
as performing an each left on successive elements of the right array):

 1 2 3 4 +\:/: 10 20 30 40 50
(11 12 13 14;21 22 23 24;31 32 33 34;41 42 43 44;51 52 53 54)

Eachright eachleft considers each element of the left array one at a time
and applies
+/: to the that element and the right array

  1 2 3 4 +/:\: 10 20 30 40 50
(11 21 31 41 51;12 22 32 42 52;13 23 33 43 53;14 24 34 44 54)


9) This also applies to binary verbs.
Examples:

g:{[a;b] a + (7 * b)}

g[2;3]
23

Eachleft considers each element of the left array one at a time and applies
g to that element and to the entire right array.

1 2 3 4 g\: 10 20
(71 141;72 142;73 143;74 144)

Eachright considers each element of the right array one at a time and applies
g to the left array and that element.

1 2 3 4 g/: 10 20
  (71 72 73 74;141 142 143 144)

Eachleft eachright considers each element of the right array one at a time
and applies
g\: to the left array and that element.

1 2 3 4 g\:/: 10 20
  (71 72 73 74;141 142 143 144)

(Try for example 1 2 3 4 g\: 20)

Eachright eachleft considers each element of the left array one at a time
and applies
g/: to the that element and the right array

1 2 3 4 g/:\: 10 20
  (71 141;72 142;73 143;74 144)

(Try for example 3 g/: 10 20)

Finally, each can apply to just one argument

 x1: 1 2 3 4
 x2: 50

 g[;x2]'x1
351 352 353 354

 g[x1]'x2
351 352 353 354


#+begin_src k

/{x^'``fizz`buzz`fizzbuzz@2/~3 5!\:x}1+!15

:x:1+!15  / sequence 1..n

/3 5!\:x /

1 2 +\:x


+\x      / assume 0 in as the initial base

0+\x     / same as this

1 +\x    / this, increment one

(#x)#1 +\x / is the same as this

1 2 3 +\x


{x^'``fizz`buzz`fizzbuzz@2/~3 5!\:x}x
#+end_src

- 22/08.k
#+begin_src k
/(-1>':|\)'(+|:)\3 3#50?50
m:3 3#50?50
r:(+|:)
(-1>':|\)'r\m
(!4) (|+:)/'mv
#+end_src

- find substring
{1<#x\y}
** Problems
*** all equal
We can solve "all equal" with =?=, but if we didn't have it

- 7 day moving avg
I'd do 7{+/x%#x}':!9. I feel it directly says "7-day moving average", whereas
{+/x%#x}'7'!9 says "the average of each 7-day window", and (7+/':!9)%7 says "one
seventh of the 7-day moving sum" and is errorprone because you have to make sure
the two sevens are equal to each other.
But (7+/':!9)%7 is prettier. Above I'm just talking about which version I'd keep
in my program, for clarity.

- "in"
if anyone needs a fast "in" for ngn/k, sorting and binary-searching can be
faster than a plain "find": in:{x@:<x;y=x@x'y} // yâˆŠx

ae:{1=&/(*x)=x}
* BQN
* Klong
- https://t3x.org/klong/
- https://github.com/briangu/klongpy
